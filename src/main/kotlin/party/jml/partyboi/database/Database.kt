package party.jml.partyboi.database

import arrow.core.*
import com.zaxxer.hikari.HikariDataSource
import io.ktor.server.application.*
import kotliquery.*
import kotliquery.action.*
import party.jml.partyboi.Config
import party.jml.partyboi.errors.AppError
import party.jml.partyboi.errors.DatabaseError
import party.jml.partyboi.errors.NotFound
import java.sql.Connection

class DatabasePool(private val dataSource: HikariDataSource) {
    fun <A> use(tx: TransactionalSession? = null, block: (Session) -> A): A =
        if (tx != null) {
            block(tx)
        } else {
            sessionOf(dataSource).use { block(it) }
        }

    fun <A> transaction(block: (TransactionalSession) -> Either<AppError, A>): Either<AppError, A> =
        sessionOf(dataSource).transactionEither { block(it) }

    fun <A> useUnsafe(block: (Session) -> A): A =
        sessionOf(dataSource).use { block(it) }

    fun init(query: String): Unit =
        sessionOf(dataSource).use { it.run(queryOf(query.trimIndent()).asExecute) }

}

fun Session.runSafely(query: ExecuteQueryAction): Either<AppError, Boolean> =
    Either.catch { run(query) }.mapLeft { DatabaseError(it.toString()) }

fun Session.runSafely(query: UpdateQueryAction): Either<AppError, Int> =
    Either.catch { run(query) }.mapLeft { DatabaseError(it.toString()) }

fun Session.runSafely(query: UpdateAndReturnGeneratedKeyQueryAction): Either<AppError, Option<Long>> =
    Either.catch { run(query).toOption() }.mapLeft { DatabaseError(it.toString()) }

fun <A> Session.runSafely(query: ListResultQueryAction<A>): Either<AppError, List<A>> =
    Either.catch { run(query) }.mapLeft { DatabaseError(it.toString()) }

fun <A> Session.runSafely(query: NullableResultQueryAction<A>): Either<AppError, Option<A>> =
    Either.catch { run(query).toOption() }.mapLeft { DatabaseError(it.toString()) }

fun <A> Session.option(query: ResultQueryActionBuilder<A>): Either<AppError, Option<A>> =
    runSafely(query.asSingle)

fun <A> Session.one(query: ResultQueryActionBuilder<A>): Either<AppError, A> =
    option(query).flatMap { it.toEither { NotFound() } }

fun <A> Session.many(query: ResultQueryActionBuilder<A>): Either<AppError, List<A>> =
    runSafely(query.asList)

fun Session.exec(query: Query): Either<AppError, Boolean> =
    runSafely(query.asExecute)

fun Session.execAlways(query: Query): Either<AppError, Unit> =
    runSafely(query.asExecute).flatMap { if (it) Unit.right() else NotFound().left() }

fun Session.updateAny(query: Query): Either<AppError, Int> =
    runSafely(query.asUpdate)

fun Session.updateOne(query: Query): Either<AppError, Unit> =
    updateAny(query).flatMap { if (it != 1) NotFound().left() else Unit.right() }

object DbBasicMappers {
    val asBoolean: (Row) -> Boolean = { it.boolean(1) }
    val asInt: (Row) -> Int = { it.int(1) }
    val asIntOrNull: (Row) -> Int? = { it.intOrNull(1) }
}

inline fun <A> Session.transactionEither(operation: (TransactionalSession) -> Either<AppError, A>): Either<AppError, A> {
    try {
        connection.begin()
        transactional = true
        val tx = TransactionalSession(connection, returnGeneratedKeys, autoGeneratedKeys, strict)
        val result = operation.invoke(tx)
        if (result.isRight()) {
            connection.commit()
        } else {
            connection.rollback()
        }
        return result
    } catch (e: Exception) {
        connection.rollback()
        throw e
    } finally {
        transactional = false
    }
}

/**
 * Makes a connection to a Postgres database.
 *
 * In order to connect to your running Postgres process,
 * please specify the following parameters in your configuration file:
 * - postgres.url -- Url of your running database process.
 * - postgres.user -- Username for database connection
 * - postgres.password -- Password for database connection
 *
 * If you don't have a database process running yet, you may need to [download]((https://www.postgresql.org/download/))
 * and install Postgres and follow the instructions [here](https://postgresapp.com/).
 * Then, you would be able to edit your url,  which is usually "jdbc:postgresql://host:port/database", as well as
 * user and password values.
 *
 *
 * @param embedded -- if [true] defaults to an embedded database for tests that runs locally in the same process.
 * In this case you don't have to provide any parameters in configuration file, and you don't have to run a process.
 *
 * @return [Connection] that represent connection to the database. Please, don't forget to close this connection when
 * your application shuts down by calling [Connection.close]
 * */
fun Application.getDatabasePool(): DatabasePool {
    Class.forName("org.postgresql.Driver")

    val host = Config.getDbHost()
    val port = Config.getDbPort()
    val database = Config.getDbDatabase()
    val url = "jdbc:postgresql://$host:$port/$database"

    return DatabasePool(HikariCP.default(url, Config.getDbUser(), Config.getDbPassword()))
}
