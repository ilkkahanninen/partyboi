package party.jml.partyboi.db

import arrow.core.*
import arrow.core.raise.either
import com.zaxxer.hikari.HikariDataSource
import io.ktor.server.application.*
import kotlinx.coroutines.runBlocking
import kotlinx.datetime.toJavaLocalDateTime
import kotliquery.*
import kotliquery.action.*
import org.flywaydb.core.api.output.MigrateResult
import party.jml.partyboi.Config
import party.jml.partyboi.Logging
import party.jml.partyboi.data.AppError
import party.jml.partyboi.data.DatabaseError
import party.jml.partyboi.data.NotFound
import java.nio.file.Path
import java.sql.Connection
import java.sql.Timestamp

class DatabasePool(val dataSource: HikariDataSource) : Logging() {
    fun <A> use(tx: TransactionalSession? = null, block: (Session) -> A): A =
        if (tx != null) {
            block(tx)
        } else {
            sessionOf(dataSource).use { block(it) }
        }

    fun <A> transaction(
        schema: String? = null,
        block: (TransactionalSession) -> Either<AppError, A>
    ): Either<AppError, A> =
        sessionOf(dataSource).use { it.transactionEither(schema) { tx -> block(tx) } }

    fun <A> useUnsafe(block: (Session) -> A): A =
        sessionOf(dataSource).use { block(it) }

    fun createSchema(name: String): Either<AppError, String> {
        val schema = transaction {
            dropSchema(it, name)
            it.exec(queryOf("CREATE SCHEMA $name"))
        }
        val self = this
        return runBlocking {
            either {
                schema.bind()
                Migrations.migrate(self, name).bind()
                name
            }
        }
    }

    fun swapSchema(tx: TransactionalSession, fromSchema: String, toSchema: String) = either {
        dropSchema(tx, toSchema).bind()
        tx.exec(queryOf("ALTER SCHEMA $fromSchema RENAME TO $toSchema")).bind()
    }

    fun copyRows(tx: TransactionalSession, fromTable: String, toTable: String) =
        tx.exec(queryOf("INSERT INTO $toTable SELECT * FROM $fromTable"))

    private fun dropSchema(tx: TransactionalSession, name: String) =
        tx.exec(queryOf("DROP SCHEMA IF EXISTS $name CASCADE"))

    fun init(query: String): Unit =
        sessionOf(dataSource).use { it.run(queryOf(query.trimIndent()).asExecute) }

    fun debugPrintPoolState(message: String) {
        val pool = dataSource.hikariPoolMXBean
        log.info("$message: ${dataSource.poolName} (total=${pool.totalConnections}, active=${pool.activeConnections}, idle=${pool.idleConnections}, waiting=${pool.threadsAwaitingConnection})")
    }

}

fun Session.runSafely(query: ExecuteQueryAction): Either<AppError, Boolean> =
    Either.catch { run(query) }.mapLeft { DatabaseError(it) }

fun Session.runSafely(query: UpdateQueryAction): Either<AppError, Int> =
    Either.catch { run(query) }.mapLeft { DatabaseError(it) }

fun Session.runSafely(query: UpdateAndReturnGeneratedKeyQueryAction): Either<AppError, Option<Long>> =
    Either.catch { run(query).toOption() }.mapLeft { DatabaseError(it) }

fun <A> Session.runSafely(query: ListResultQueryAction<A>): Either<AppError, List<A>> =
    Either.catch { run(query) }.mapLeft { DatabaseError(it) }

fun <A> Session.runSafely(query: NullableResultQueryAction<A>): Either<AppError, Option<A>> =
    Either.catch { run(query).toOption() }.mapLeft { DatabaseError(it) }

fun <A> Session.option(query: ResultQueryActionBuilder<A>): Either<AppError, Option<A>> =
    runSafely(query.asSingle)

fun <A> Session.one(query: ResultQueryActionBuilder<A>): Either<AppError, A> =
    option(query).flatMap { it.toEither { NotFound("Not found") } }

fun <A> Session.many(query: ResultQueryActionBuilder<A>): Either<AppError, List<A>> =
    runSafely(query.asList)

fun Session.exec(query: Query): Either<AppError, Unit> =
    runSafely(query.asExecute).map {}

fun Session.updateAny(query: Query): Either<AppError, Int> =
    runSafely(query.asUpdate)

fun Session.updateOne(query: Query): Either<AppError, Unit> =
    updateAny(query).flatMap { if (it != 1) NotFound("Not found").left() else Unit.right() }

object DbBasicMappers {
    val asBoolean: (Row) -> Boolean = { it.boolean(1) }
    val asInt: (Row) -> Int = { it.int(1) }
    val asIntOrNull: (Row) -> Int? = { it.intOrNull(1) }
}

inline fun <A> Session.transactionEither(
    schema: String?,
    operation: (TransactionalSession) -> Either<AppError, A>
): Either<AppError, A> {
    try {
        connection.begin()
        transactional = true
        val tx = TransactionalSession(connection, returnGeneratedKeys, autoGeneratedKeys, strict)
        if (schema != null) {
            tx.exec(queryOf("SET search_path TO $schema"))
        }
        val result = operation.invoke(tx)
        if (result.isRight()) {
            connection.commit()
        } else {
            connection.rollback()
        }
        return result
    } catch (e: Exception) {
        connection.rollback()
        throw e
    } finally {
        transactional = false
        if (schema != null) {
            exec(queryOf("SET search_path TO public"))
        }
    }
}

fun queryOf(statement: String, vararg params: Any?): Query {
    return Query(statement, params = params.toList().map { convertQueryParam(it) })
}

fun convertQueryParam(param: Any?): Any? = when (param) {
    is Option<*> -> param.getOrNull()
    is kotlinx.datetime.LocalDateTime -> Timestamp.valueOf(param.toJavaLocalDateTime())
    is java.time.LocalDateTime -> Timestamp.valueOf(param)
    is Path -> param.toString()
    is Enum<*> -> param.name
    is List<*> -> throw RuntimeException("Pass a typed array instead of List to a query")
    else -> param
}

/**
 * Makes a connection to a Postgres database.
 *
 * In order to connect to your running Postgres process,
 * please specify the following parameters in your configuration file:
 * - postgres.url -- Url of your running database process.
 * - postgres.user -- Username for database connection
 * - postgres.password -- Password for database connection
 *
 * If you don't have a database process running yet, you may need to [download]((https://www.postgresql.org/download/))
 * and install Postgres and follow the instructions [here](https://postgresapp.com/).
 * Then, you would be able to edit your url,  which is usually "jdbc:postgresql://host:port/database", as well as
 * user and password values.
 *
 *
 * @param embedded -- if [true] defaults to an embedded database for tests that runs locally in the same process.
 * In this case you don't have to provide any parameters in configuration file, and you don't have to run a process.
 *
 * @return [Connection] that represent connection to the database. Please, don't forget to close this connection when
 * your application shuts down by calling [Connection.close]
 * */
fun Application.getDatabasePool(): DatabasePool {
    Class.forName("org.postgresql.Driver")

    val host = Config.getDbHost()
    val port = Config.getDbPort()
    val database = Config.getDbDatabase()
    val url = "jdbc:postgresql://$host:$port/$database"

    return DatabasePool(HikariCP.default(url, Config.getDbUser(), Config.getDbPassword()))
}
